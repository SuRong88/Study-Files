# 前端进阶高薪必看-HTTPS篇



**前言**

此系列作为笔者之前发过的[前端高频面试整理](https://juejin.cn/post/6844904148899463175)的补充 会比较偏向中高级前端面试问题 当然大家都是从新手一路走过来的 感兴趣的朋友们都可以看哈

我相信大家面试的时候对于**HTTPS**这个问题一定不会陌生 可能作为前端只能简单的说一下与 HTTP 的区别 但是真正的原理是否很清楚呢 他到底如何安全 这一篇让我们用大白话来揭开 HTTPS 的神秘面纱吧

## 1 HTTPS 是什么

答：HTTPS 不就是 HTTP 后面多加了一个 S 吗

对 这里的 S 就是指 SSL/TLS（*就是一种安全加密协议--想深入了解的同学可以自行百度*）

HTTPS 是在 HTTP 的基础上，利用 SSL/TLS 加密数据包。

> 我们记住两个主要目的就行：1.对数据加密 2.验证网站服务器身份

## 2 HTTPS 怎么对数据进行加密

我们已经知道 HTTPS 第一个目的是给数据加密

对于数据加密 我们这里要谈到两种加密方式 **对称加密**和**非对称加密**

- 对称加密：所谓对称 就是指两边一样 发送方和接收方都用的同一个密钥 加密解密都是同一个密钥 从始至终只需要保存**一个密钥**就行
- 非对称加密：发送方和接收方使用**一对密钥**，即**公钥和私钥**。一般私钥是保密不能被泄露的，公钥可以对外传播。我们可以用公钥加密私钥解密（数据加密） 也可用私钥加密公钥解密（签名--下面会解释）

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3727a8c3dd614cb2a001947938bb6f2c~tplv-k3u1fbpfcp-watermark.awebp)

| 加密方式   | 优点   | 缺点                                                         |
| ---------- | ------ | ------------------------------------------------------------ |
| 对称加密   | 速度快 | 密钥不可能一开始在发送方和接收方都全部生成好了 需要在一方生成之后传递给另一方 如果在传递过程密钥被劫持 整个加密就不安全了 |
| 非对称加密 | 较安全 | 1.加解密速度慢-数据传输效率降低 2.公钥对外公开 如果密文是私钥加密 那么任何人都能用公钥解密 |

**混合加密**

知道了两种加密方式的优缺点之后 我们的HTTPS就很厉害了 它采用两者混合的加密方式 不是说对称加密的密钥不安全吗 那我们换一种思路 我们在传递过程把我们的对称加密中的密钥用非对称加密的方式去传递就好了 哈哈 这句话有点绕 我们上图

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63f3952aafc544119f892acfcf94a957~tplv-k3u1fbpfcp-watermark.awebp)

1. 客户端生成会话秘钥就是我们对称加密生成的密钥
2. 它用公钥加密之后进行传递(这个时候被加密的不是数据 是这个会话秘钥 等于把钥匙加密了) 这里的公钥就是非对称加密中的公钥 他是由服务器传递过去的（对外公开）
3. 服务端用非对称加密的私钥去解密 拿到我们的会话秘钥
4. 客户端和服务端都能用同一个会话秘钥进行加解密了

**就算传输过程被攻击者截取到了被加密的会话秘钥 他没有服务器的私钥是无法得到会话秘钥的**

> 整个过程巧妙之处就在于 之前我们传递的是钥匙 现在我们传递的是保险箱 钥匙在保险箱里面 你就算拿到了保险箱 没有保险箱的钥匙也拿不到钥匙

## 3 HTTPS 怎么验证网站服务器身份

HTTPS 第二个目的是对网站服务器进行真实身份认证

那么这一点又是怎么做到的呢？

先来看一个问题 上一步我们已经解决了数据加密的问题 虽然攻击者无法解密数据 但是他可以**篡改数据** 我们怎么知道数据没被动过呢

### 3.1数据被篡改怎么办

这个时候就要使用**数字签名**了

- 数字签名：将原文（部分数据关键信息）先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文一起传送给接收者

> 两个关键点：1.Hash算法计算生成信息摘要 2.私钥加密生成数字签名

客户端如何校验数字签名呢？（利用服务器私钥加密 公钥解密）

客户端收到服务器发过来的数字签名之后

1. 用服务端的公钥去解密数字签名得到消息摘要 （原始未被篡改的）
2. 用HASH函数对收到的原文计算生成一个摘要信息 （可能会被篡改的）

如果两个信息摘要一致 说明数据没有被篡改

ok 到这里可能你觉得没问题了

其实最后还有一个很关键的点是 我们刚刚所有的假设都基于 客户端的公钥是服务器传递过来的 那如果攻击者伪造了服务器的公钥怎么办呢

### 3.2服务器公钥被篡改怎么办

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/889991629983488f87e4af051f1dec76~tplv-k3u1fbpfcp-watermark.awebp)

这个时候就要使用**数字证书**了

- 数字证书认证机构（CA）处于客户端与服务器双方都可信赖的第三方机构的立场上

服务端向CA申请数字证书 审核通过后CA会向申请者签发认证文件-证书 包含以下内容 ![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bac25b12dd194ddeb901b976b0bfd056~tplv-k3u1fbpfcp-watermark.awebp)

拿到数字证书后 服务器传递数字证书给客户端

### 3.3客户端怎么校验数字证书

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2e2071b0248499bae82706ae36768e6~tplv-k3u1fbpfcp-watermark.awebp)

1. 首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验
2. 浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发
3. 如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密
4. 浏览器使用相同的hash算法根据证书内容计算出信息摘要，将这个计算的值与证书解密的值做对比
5. 对比结果一致，则证明服务器发来的证书合法，没有被冒充。此时浏览器就可以读取证书中的公钥，用于后续加密了

## HTTPS原理一览图

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c3de1334624747b5b74808a9c1d7585b~tplv-k3u1fbpfcp-watermark.awebp)